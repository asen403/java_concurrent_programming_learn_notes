# ReadWriteLock：如何快速实现一个完备的缓存

理论上并发所有的问题都可以用我们前面讲到的管程模型和信号量模型来解决，那为什么Java并发包里还有那么多别的工具类呢？
答案就是：分场景优化性能，提升易用性
例如ReadWriteLock接口，针对读多写少的场景做了优化，提升了性能
如果我们使用管程模型来构建一个线程安全的集合，那么在读元素和写元素的时候都要加上相同的锁才能确保线程安全
即集合的读和写是互斥串行的，而ReadWriteLock针对这种场景将锁的粒度降到更低
ReadWriteLock读写锁的特点是：

1. 允许多个线程同时读共享变量
2. 只允许一个线程同一时间写共享变量
3. 写操作和读操作互斥

所以读写锁相比于传统的管程模型就是将锁的粒度分为了读锁和写锁

## 快速实现一个缓存

代码见本包下`Cache.java`

注意：ReadWriteLock中的读锁和写锁均实现了Lock接口，所以除了`lock()`方法外，也支持`tryLock()`
、`lockInterruptibly()`等方法

## 实现缓存的按需加载

代码见本包下`LazyLoadCache.java`
注意：在获取写锁后需再次查询判断缓存是否有值，防止在获取写锁阻塞期间缓存已经被加载

## 读写锁的升级与降级

锁升级是指从低级别锁升级到高级别锁，即从读锁升级到写锁
锁降级是指从高级别锁降级到低级别锁，即从写锁降级到读锁

示例代码见本包下`ReadWriteLockUpgradeAndDowngradeExample.java`
根据代码运行结果可知：ReadLockLock支持锁降级不支持锁升级
