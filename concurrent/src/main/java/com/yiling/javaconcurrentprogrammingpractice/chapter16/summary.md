# Semaphore：如何快速实现一个限流器

## 信号量模型

信号量模型和前面讲的管程模型一样，也是解决多线程之间的互斥和同步问题的

![img.png](img.png)
信号量模型是一种较低级的同步原语，它功过一个计数器来控制对共享变量的访问。
信号量本质上是一个整数变量和一个等待队列，该变量的值表示当前资源的数量，当资源数量被消耗完时后面的线程会被放入等待队列，等资源恢复再唤醒
信号量有三个基本的操作：

* init():初始化整数变量的值
* down():整数变量的值减1，如果操作结果小于0则当前线程被阻塞，否则继续执行
* up():整数变量的值加1，如果操作结果大于等于0则唤醒等待队列中的一个线程，并将其从等待队列中移除

这三个基本操作都有信号量模型的实现方保证的
管程模型在Java中的实现是synchronized关键字、Lock和Condition接口，而信号量模型在Java中的实现是Semaphore接口
在Semaphore接口中对应上述三个基本操作的方法分别是构造方法、acquire()、release()

而信号量模型中的down()和up()的两个操作最早被称为P操作和V操作，所以信号量模型也被叫做PV原语

## 如何使用信号量

使用示例见本包下的SemaphoreExample.java
需要注意的是，Semaphore中的release()操作类似于管程模型中的释放锁操作，所以建议也放到finally代码块中执行

## 快速实现一个限流器

上面的例子中我们使信号量的资源数量设置为1来实现互斥锁，但是使用信号量模型实现互斥锁的操作显然不够简洁和直观
而信号量模型一定有区别于管程模型的使用场景才能够证明它存在的价值
那就是：**Semaphore可以允许多个线程访问一个临界区**
这种使用场景最常见的就是各种池化资源，例如线程池、连接池、对象池等，一个池中存在多个资源，自然需要允许多个线程同时操作这个池
但是也要保证一个资源只能被一个线程占有，所以就要控制同一时间访问该池的线程数量，这时信号量模型就很方便了

具体代码见本包下的ObjPool.java

## 总结

信号量模型和管程模型的比较：

| 特性   | 管程模型Monitor               | 信号量模型Semaphore     |
|------|---------------------------|--------------------|
| 定义   | 封装共享资源和访问资源的操作，提供互斥锁和条件变量 | 通过一个计数器控制访问资源并发的数量 |
| 同步机制 | 支持加锁和解锁，支持条件变量及对应的等待队列    | 支持计数器增加和减少操作       |
| 适用场景 | 多用于互斥和同步                  | 适用于限制并发资源访问数量      |
